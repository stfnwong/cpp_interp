/*
 * ASTPRINTER
 * Print any Lox AST
 */

#ifndef __ASTPRINTER_HPP
#define __ASTPRINTER_HPP


#include "Expr.hpp"
#include "Statement.hpp"


/*
 * ASTPrinter
 *
 * Return type has to be LoxObject here to make it possible to print the objects 
 * generated by the Parser (which are templated to return LoxObject for the Interpterer)
 * This is somewhat annoying because what we really want to do is return strings, but
 * we can return a string LoxObject instead which mostly gives us what we want.
 *
 * This design choice mostly reflects a lack of thought on my part.
 */
struct ASTPrinter : public ExprVisitor<LoxObject, LoxObject>, public StmtVisitor<LoxObject, LoxObject>
{
    using E = LoxObject;
    using T = LoxObject;
    using ExprPtr = std::unique_ptr<Expr<E, T>>;

    public:
        std::string print(Stmt<E, T>& stmt) {
            return stmt.accept(*this).to_string();
        }

        std::string print(Expr<E, T>& expr) {
            return expr.accept(*this).to_string();
        }

        // Expressions
        LoxObject visit(LiteralExpr<E, T>& expr) final
        {
            return expr.value;
            //return expr.value.to_string();
        }

        LoxObject visit(UnaryExpr<E, T>& expr) final
        {
            std::ostringstream oss;
            oss << "(" << expr.op.lexeme << " ";
            oss << expr.right->accept(*this).to_string();
            oss << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(BinaryExpr<E, T>& expr) final
        {
            std::ostringstream oss;
            oss << "(" << expr.op.lexeme;
            oss << " " << expr.left->accept(*this).to_string();
            oss << " " << expr.right->accept(*this).to_string();
            oss << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(GroupingExpr<E, T>& expr) final
        {
            std::ostringstream oss;
            oss << "(" << expr.left->accept(*this).to_string() << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(VariableExpr<E, T>& expr) final
        {
            std::ostringstream oss;
            oss << "(var " << expr.token.to_string() << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(AssignmentExpr<E, T>& expr) final 
        {
            std::ostringstream oss;
            oss << "(" << expr.token.lexeme << " = " << expr.expr->to_string() << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(LogicalExpr<E, T>& expr) final 
        {
            std::ostringstream oss;
            oss << "(" << expr.op.to_string() 
                << " " << expr.left.get()->to_string()
                << " " << expr.right.get()->to_string() << ")";
            return LoxObject(oss.str());
        }

        // Statements
        LoxObject visit(PrintStmt<E, T>& stmt) final 
        {
            return stmt.expr->accept(*this);
        }

        LoxObject visit(ExpressionStmt<E, T>& stmt) final
        {
            return stmt.expr->accept(*this);
        }

        LoxObject visit(VariableStmt<E, T>& stmt) final
        {
            // TODO: this is just to prevent segfault when Variable is empty, 
            // however this should never be the case
            return (stmt.expr.get() != nullptr) ? stmt.expr->accept(*this) : LoxObject();
        }

        LoxObject visit(BlockStmt<E, T>& stmt) final
        {
            std::ostringstream oss;
            oss << "(Block " << std::endl;
            for(unsigned i = 0; i < stmt.statements.size(); ++i)
                oss << "  - " << stmt.statements[i].get()->accept(*this).to_string() << std::endl;
            oss << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(IfStmt<E, T>& stmt) final
        {
            return LoxObject(stmt.to_string());
        }

        LoxObject visit(WhileStmt<E, T>& stmt) final
        {
            return LoxObject(stmt.to_string());
        }
};




#endif /*__ASTPRINTER_HPP*/
