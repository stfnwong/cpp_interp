/*
 * ASTPRINTER
 * Print any Lox AST
 */

#ifndef __ASTPRINTER_HPP
#define __ASTPRINTER_HPP


#include "Expr.hpp"
#include "Statement.hpp"


/*
 * ASTPrinter
 *
 * Return type has to be LoxObject here to make it possible to print the objects 
 * generated by the Parser (which are templated to return LoxObject for the Interpterer)
 * This is somewhat annoying because what we really want to do is return strings, but
 * we can return a string LoxObject instead which mostly gives us what we want.
 *
 * This design choice mostly reflects a lack of thought on my part.
 */
struct ASTPrinter : public ExprVisitor<LoxObject, LoxObject>, public StmtVisitor<LoxObject, LoxObject>
{
    using E = LoxObject;
    using T = LoxObject;
    using ExprPtr = std::unique_ptr<Expr<E, T>>;

    public:
        std::string print(Stmt<E, T>& stmt) {
            return stmt.accept(*this).to_string();
        }

        std::string print(Expr<E, T>& expr) {
            return expr.accept(*this).to_string();
        }

        // Expressions
        LoxObject visit(LiteralExpr<E, T>& expr) final
        {
            return expr.value;
            //return expr.value.to_string();
        }

        LoxObject visit(UnaryExpr<E, T>& expr) final
        {
            std::ostringstream oss;
            oss << "(" << expr.op.lexeme << " ";
            oss << expr.right->accept(*this).to_string();
            oss << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(BinaryExpr<E, T>& expr) final
        {
            std::ostringstream oss;
            oss << "(" << expr.op.lexeme;
            oss << " " << expr.left->accept(*this).to_string();
            oss << " " << expr.right->accept(*this).to_string();
            oss << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(GroupingExpr<E, T>& expr) final
        {
            std::ostringstream oss;
            oss << "(" << expr.left->accept(*this).to_string() << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(VariableExpr<E, T>& expr) final
        {
            std::ostringstream oss;
            oss << "(var " << expr.token.to_string() << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(AssignmentExpr<E, T>& expr) final 
        {
            std::ostringstream oss;
            oss << "(" << expr.token.lexeme << " = " << expr.expr->to_string() << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(LogicalExpr<E, T>& expr) final 
        {
            std::ostringstream oss;
            oss << "(" << expr.op.to_string() 
                << " " << expr.left.get()->to_string()
                << " " << expr.right.get()->to_string() << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(CallExpr<E, T>& expr) final 
        {
            std::ostringstream oss;

            oss << "(" << expr.callee->to_string() << " ";
            for(unsigned i = 0; i < expr.arguments.size(); ++i)
                oss << expr.arguments[i]->to_string() << ",";
            oss << ")";

            return LoxObject(oss.str());
        }

        // Statements
        LoxObject visit(PrintStmt<E, T>& stmt) final 
        {
            std::ostringstream oss;
            oss << "(print " << stmt.expr->accept(*this).to_string() << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(ExpressionStmt<E, T>& stmt) final
        {
            std::ostringstream oss;
            oss << "(expr " << stmt.expr->accept(*this).to_string() << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(VariableStmt<E, T>& stmt) final
        {
            // TODO: this is just to prevent segfault when Variable is empty, 
            // This is the case when a variable is declared but not assigned.
            return (stmt.expr.get() != nullptr) ? stmt.expr->accept(*this) : LoxObject(stmt.token.lexeme);
        }

        LoxObject visit(BlockStmt<E, T>& stmt) final
        {
            std::ostringstream oss;
            oss << "(block " << std::endl;
            for(unsigned i = 0; i < stmt.statements.size(); ++i)
                oss << "     " << i << ") " << stmt.statements[i]->accept(*this).to_string() << std::endl;
            oss << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(IfStmt<E, T>& stmt) final
        {
            std::ostringstream oss;
            oss << "(if " << stmt.to_string() << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(WhileStmt<E, T>& stmt) final
        {
            std::ostringstream oss;
            //oss << "(while " << stmt.to_string() << ")";
            oss << "(while ";
            oss << stmt.cond->accept(*this).to_string() << ", ";
            oss << stmt.body->accept(*this).to_string() << ", ";
            oss << ")";
            return LoxObject(oss.str());
        }

        LoxObject visit(FunctionStmt<E, T>& stmt) final
        {
            std::ostringstream oss;
            oss << "(" << stmt.name.lexeme << " ";
            for(unsigned i = 0; i < stmt.params.size(); ++i)
            {
                oss << stmt.params[i].lexeme;
                if(i < stmt.params.size()-1)
                    oss << ",";
            }

            return LoxObject(oss.str());
        }
};




#endif /*__ASTPRINTER_HPP*/
